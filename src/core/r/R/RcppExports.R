# Generated by Rcpp::compileAttributes() - edits will be overwritten

#' Compute band accuracy
#' @param pred Numeric vector of predictions
#' @param target Numeric vector of targets
#' @param threshold Band threshold (default 0.25)
#' @return Band accuracy as double
resolve_band_accuracy <- function(pred, target, threshold = 0.25) {
    .Call(`_resolve_resolve_band_accuracy`, pred, target, threshold)
}

#' Compute mean absolute error
#' @param pred Numeric vector of predictions
#' @param target Numeric vector of targets
#' @return MAE as double
resolve_mae <- function(pred, target) {
    .Call(`_resolve_resolve_mae`, pred, target)
}

#' Compute root mean squared error
#' @param pred Numeric vector of predictions
#' @param target Numeric vector of targets
#' @return RMSE as double
resolve_rmse <- function(pred, target) {
    .Call(`_resolve_resolve_rmse`, pred, target)
}

#' Compute symmetric mean absolute percentage error
#' @param pred Numeric vector of predictions
#' @param target Numeric vector of targets
#' @param eps Small value to avoid division by zero
#' @return SMAPE as double
resolve_smape <- function(pred, target, eps = 1e-8) {
    .Call(`_resolve_resolve_smape`, pred, target, eps)
}

#' Create a new ResolveModel
#' @param schema_list List with schema parameters
#' @param config_list List with model config parameters
#' @return External pointer to model
resolve_model_new <- function(schema_list, config_list) {
    .Call(`_resolve_resolve_model_new`, schema_list, config_list)
}

#' Forward pass through model
#' @param model_ptr External pointer to model
#' @param continuous Numeric matrix of continuous features
#' @param genus_ids Integer matrix of genus IDs (optional)
#' @param family_ids Integer matrix of family IDs (optional)
#' @return List of predictions
resolve_model_forward <- function(model_ptr, continuous, genus_ids = NULL, family_ids = NULL) {
    .Call(`_resolve_resolve_model_forward`, model_ptr, continuous, genus_ids, family_ids)
}

#' Get latent embeddings from model
#' @param model_ptr External pointer to model
#' @param continuous Numeric matrix of continuous features
#' @param genus_ids Integer matrix of genus IDs (optional)
#' @param family_ids Integer matrix of family IDs (optional)
#' @return Numeric matrix of latent embeddings
resolve_model_get_latent <- function(model_ptr, continuous, genus_ids = NULL, family_ids = NULL) {
    .Call(`_resolve_resolve_model_get_latent`, model_ptr, continuous, genus_ids, family_ids)
}

#' Create a new Trainer
#' @param model_ptr External pointer to ResolveModel
#' @param config_list List with training config parameters
#' @return External pointer to Trainer
resolve_trainer_new <- function(model_ptr, config_list) {
    .Call(`_resolve_resolve_trainer_new`, model_ptr, config_list)
}

#' Prepare training data
#' @param trainer_ptr External pointer to Trainer
#' @param continuous Numeric matrix of continuous features
#' @param targets_list Named list of numeric vectors (targets)
#' @param genus_ids Integer matrix of genus IDs (optional)
#' @param family_ids Integer matrix of family IDs (optional)
#' @param test_size Fraction for test set (default 0.2)
#' @param seed Random seed
resolve_trainer_prepare_data <- function(trainer_ptr, continuous, targets_list, genus_ids = NULL, family_ids = NULL, test_size = 0.2, seed = 42L) {
    invisible(.Call(`_resolve_resolve_trainer_prepare_data`, trainer_ptr, continuous, targets_list, genus_ids, family_ids, test_size, seed))
}

#' Train the model
#' @param trainer_ptr External pointer to Trainer
#' @return List with training results
resolve_trainer_fit <- function(trainer_ptr) {
    .Call(`_resolve_resolve_trainer_fit`, trainer_ptr)
}

#' Save trainer checkpoint
#' @param trainer_ptr External pointer to Trainer
#' @param path File path to save
resolve_trainer_save <- function(trainer_ptr, path) {
    invisible(.Call(`_resolve_resolve_trainer_save`, trainer_ptr, path))
}

#' Load trainer checkpoint
#' @param path File path to load
#' @return List with model_ptr and scalers
resolve_trainer_load <- function(path) {
    .Call(`_resolve_resolve_trainer_load`, path)
}

#' Create a new Predictor
#' @param model_ptr External pointer to ResolveModel
#' @param scalers_ptr External pointer to Scalers
#' @return External pointer to Predictor
resolve_predictor_new <- function(model_ptr, scalers_ptr) {
    .Call(`_resolve_resolve_predictor_new`, model_ptr, scalers_ptr)
}

#' Load predictor from checkpoint
#' @param path File path to load
#' @return External pointer to Predictor
resolve_predictor_load <- function(path) {
    .Call(`_resolve_resolve_predictor_load`, path)
}

#' Predict with Predictor
#' @param predictor_ptr External pointer to Predictor
#' @param continuous Numeric matrix of continuous features
#' @param genus_ids Integer matrix of genus IDs (optional)
#' @param family_ids Integer matrix of family IDs (optional)
#' @param return_latent Whether to return latent embeddings
#' @return List of predictions
resolve_predictor_predict <- function(predictor_ptr, continuous, genus_ids = NULL, family_ids = NULL, return_latent = FALSE) {
    .Call(`_resolve_resolve_predictor_predict`, predictor_ptr, continuous, genus_ids, family_ids, return_latent)
}

#' Get latent embeddings
#' @param predictor_ptr External pointer to Predictor
#' @param continuous Numeric matrix of continuous features
#' @param genus_ids Integer matrix of genus IDs (optional)
#' @param family_ids Integer matrix of family IDs (optional)
#' @return Numeric matrix of latent embeddings
resolve_predictor_get_embeddings <- function(predictor_ptr, continuous, genus_ids = NULL, family_ids = NULL) {
    .Call(`_resolve_resolve_predictor_get_embeddings`, predictor_ptr, continuous, genus_ids, family_ids)
}

#' Get learned genus embeddings
#' @param predictor_ptr External pointer to Predictor
#' @return Numeric matrix of genus embeddings
resolve_predictor_get_genus_embeddings <- function(predictor_ptr) {
    .Call(`_resolve_resolve_predictor_get_genus_embeddings`, predictor_ptr)
}

#' Get learned family embeddings
#' @param predictor_ptr External pointer to Predictor
#' @return Numeric matrix of family embeddings
resolve_predictor_get_family_embeddings <- function(predictor_ptr) {
    .Call(`_resolve_resolve_predictor_get_family_embeddings`, predictor_ptr)
}

#' Check if CUDA is available
#' @return TRUE if CUDA is available
resolve_cuda_available <- function() {
    .Call(`_resolve_resolve_cuda_available`)
}

#' Get CUDA device count
#' @return Number of CUDA devices
resolve_cuda_device_count <- function() {
    .Call(`_resolve_resolve_cuda_device_count`)
}
